#!/usr/bin/env python3
# coding: utf-8

import numpy as np
import gsd.hoomd
import hoomd
import cupy

from pathlib import Path
from argparse import ArgumentParser

from wca_solvation import setup_table_writer, setup_nonequilibrium_simulation_with_policy

PROJECT_DIR = Path().resolve()

parser = ArgumentParser(
    prog=Path(__file__).name, usage='%(prog)s [options]',
    description='''Generate denoising trajectories to estimate the
                   time-reversed work to solvate a monomer in WCA solvent''')

# system parameters
parser.add_argument('-ρ', type=float, default=0.96,
                    help='system density', metavar=' ')
parser.add_argument('-σ', type=float, default=1.0,
                    help='WCA sigma', metavar=' ')
parser.add_argument('-ε', type=float, default=1.0,
                    help='WCA epsilon', metavar=' ')
parser.add_argument('-φ', type=float, default=2.0,
                    help='WCA sigma ratio of fully grown solute over solvent', metavar=' ')
parser.add_argument('-β', type=float, default=0.824,
                    help='inverse temperature', metavar=' ')
parser.add_argument('-λ', type=str, required=True,
                    help='potential switching parameter', metavar=' ')
parser.add_argument('-reversed', action='store_true',
                    help='reverse the direction of potential switching')

# simulation parameters
parser.add_argument('-dt', type=float, default=5e-5, metavar=' ',
                    help='simulation stepsize')
parser.add_argument('-N_particles', type=int, default=8,
                    help='_cubic root_ of the number of particles', metavar=' ')
parser.add_argument('-N_timesteps', type=int, default=20_000, metavar=' ',
                    help='number of simulation steps (first half spent in burn-in)')
parser.add_argument('-N_dumpevery', type=int, default=200, metavar=' ',
                    help='number of simulation steps skipped per frame dumped')
parser.add_argument('-N_trajectories', type=int, default=1, metavar=' ',
                    help='number of trajectories integrated')
parser.add_argument('-first_traj_index', type=int, default=0, metavar=' ',
                    help='index of first integrated trajectory')

# file system parameters
parser.add_argument('-work_dir', type=str, required=True,
                    help='path to parent directory of initial frame data (".gsd")', metavar=' ')
parser.add_argument('-input_dir_suffix', type=str, default='', metavar=' ',
                    help='basename of input directory from where data is loaded')
parser.add_argument('-output_dir_suffix', type=str, default='noising', metavar=' ',
                    help='basename of output directory to where data is saved')
parser.add_argument('-input_name_suffix', type=str, default='', metavar=' ',
                    help='basename of input files with name pattern '
                         'f"noising{suffix}_{index:04d}.gsd"')
parser.add_argument('-output_name_suffix', type=str, default='', metavar=' ',
                    help='output trajectories will have the name pattern '
                         'f"denoising{suffix}_{index:04d}.gsd"')
parser.add_argument('-no_overwrites', action='store_true',
                    help='if "True", DO NOT overwrite files with the '
                         'same name as those generated by this script')
parser.add_argument('-gpu_id', type=int, default=None, metavar=' ',
                    help='GPU ID of CUDA-capable device to run simulations on')

# policy parameters
parser.add_argument('-i_type', type=str, default='A',
                    help='particle type `I` in the pair type `(I, J)`')
parser.add_argument('-j_type', type=str, default='B',
                    help='particle type `J` in the pair type `(I, J)`')
parser.add_argument('-N_neighs', type=int, default=12,
                     help='number of nearest neighboring `(I, J)` pairs for force evaluations')
parser.add_argument('-model_basename', required=True, type=str, metavar=' ',
                    help=('basename of path to PyTorch (".pt") file '
                          'containing optimized parameters for the '
                          'stiffness model'))

if __name__ == '__main__':

    args = parser.parse_args()
    parameters = vars(args)

    cupy.cuda.runtime.setDevice(args.gpu_id)
    device = hoomd.device.GPU(notice_level=2, gpu_id=args.gpu_id)
    random = np.random.default_rng(seed=None)

    project_path = PROJECT_DIR.joinpath(f'{args.work_dir}')
    assert project_path.is_dir()

    input_path = project_path.joinpath(f'{args.input_dir_suffix}')
    assert input_path.is_dir()

    output_path = project_path.joinpath(f'{args.output_dir_suffix}')
    output_path.mkdir(parents=True, exist_ok=True)

    for index in range(args.first_traj_index,
                       args.first_traj_index+args.N_trajectories):
        print(f'Working on trajectory {index:04d}')

        # Resolve path to input trajectory
        input_trajectory = input_path.joinpath(
            f'noising{args.input_name_suffix}_{index:04d}.gsd')
        assert input_trajectory.is_file()

        # Resolve path to output trajectory
        output_trajectory = output_path.joinpath(
            f'denoising{args.output_name_suffix}_{index:04d}.gsd')
        if args.no_overwrites and output_trajectory.exists():
            print(f'File "{str(output_trajectory)}" already exists')
            continue

        # Resolve file path to the trained PyTorch policy
        model_path = project_path.joinpath(
            f'{args.input_dir_suffix.strip()}', f'{args.model_basename.strip()}')
        assert model_path.is_file()

        # Instantiate simulation
        simulation, logger = setup_nonequilibrium_simulation_with_policy(
            parameters, device, random, str(input_trajectory), str(model_path))

        # Define a trigger that waits a burn-in period before writing output to file
        trigger = hoomd.trigger.Periodic(int(parameters["N_dumpevery"]), 1)

        # Instantiate a writer that will write trajectory and observable data
        gsd_writer = hoomd.write.GSD(
            filename=output_trajectory, mode='wb', trigger=trigger,
            filter=hoomd.filter.All(), logger=logger)
        simulation.operations.writers.append(gsd_writer)

        # Define additional writer for tabular output of scalar loggables
        _ = setup_table_writer(simulation, logger, output_trajectory)

        simulation.run(parameters["N_timesteps"], write_at_start=True)
        simulation.operations.writers[0].flush()
