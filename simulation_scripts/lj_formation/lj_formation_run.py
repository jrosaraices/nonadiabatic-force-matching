#!/usr/bin/env python3
# coding: utf-8

import numpy as np
import gsd.hoomd
import hoomd
import cupy

from pathlib import Path
from argparse import ArgumentParser

from lj_formation import setup_table_writer, setup_nonequilibrium_simulation

PROJECT_DIR = Path().resolve()

parser = ArgumentParser(
    prog=Path(__file__).name, usage='%(prog)s [options]',
    description='''Generate noising trajectories for the LJ system
                   to estimate an upper bound on the free-energy difference''')

# system parameters
parser.add_argument('-σ', type=float, default=1.0,
                    help='LJ sigma', metavar=' ')
parser.add_argument('-ε', type=float, default=1.0,
                    help='LJ epsilon', metavar=' ')
parser.add_argument('-κ', type=float, default=100.0,
                    help='stiffness of HO potential', metavar=' ')
parser.add_argument('-β', type=float, default=1.0,
                    help='inverse temperature', metavar=' ')
parser.add_argument('-ρ', type=float, default=1.28,
                    help='crystal density', metavar=' ')
parser.add_argument('-λ', type=float, required=True,
                    help='potential mixing parameter', metavar=' ')
parser.add_argument('-reversed', action='store_true',
                    help='reverse the direction of potential switching')

# simulation parameters
parser.add_argument('-dt', type=float, default=1e-4, metavar=' ',
                    help='simulation stepsize')
parser.add_argument('-N_cells_per_side', type=int, default=5,
                    help='number of unit cells per side', metavar=' ')
parser.add_argument('-N_timesteps', type=int, default=100_000, metavar=' ',
                    help='number of simulation steps in each trajectory')
parser.add_argument('-N_dumpevery', type=int, default=100, metavar=' ',
                    help='number of simulation steps skipped per frame dumped')
parser.add_argument('-N_trajectories', type=int, default=1, metavar=' ',
                    help='number of trajectories integrated')
parser.add_argument('-first_traj_index', type=int, default=0, metavar=' ',
                    help='index of first integrated trajectory')

# file system parameters
parser.add_argument('-work_dir', type=str, required=True,
                    help='path to parent directory of initial frame data (".gsd")', metavar=' ')
parser.add_argument('-input_dir_suffix', type=str, default='', metavar=' ',
                    help='basename of input directory from where data is loaded')
parser.add_argument('-output_dir_suffix', type=str, default='', metavar=' ',
                    help='basename of output directory to where data is saved')
parser.add_argument('-input_name', type=str, default='equilibrium', metavar=' ',
                    help='basename of input files with name pattern '
                         'f"{input_name}_{index:04d}.gsd"')
parser.add_argument('-output_name_suffix', type=str, default='', metavar=' ',
                    help='output trajectories will have the name pattern '
                         'f"nonequilibrium{suffix}_{index:04d}.gsd"')
parser.add_argument('-no_overwrites', action='store_true',
                    help='if passed, DO NOT overwrite files with the'
                         'same name as those generated by this script')
parser.add_argument('-gpu_id', type=int, default=None, metavar=' ',
                    help='GPU ID of CUDA-capable device to run simulations on')


if __name__ == '__main__':

    args = parser.parse_args()
    parameters = vars(args)

    cupy.cuda.runtime.setDevice(args.gpu_id)
    device = hoomd.device.GPU(notice_level=2, gpu_id=args.gpu_id)
    random = np.random.default_rng(seed=None)

    project_path = PROJECT_DIR.joinpath(f'{args.work_dir}')
    assert project_path.is_dir()

    input_path = project_path.joinpath(f'{args.input_dir_suffix}')
    assert input_path.is_dir()

    output_path = project_path.joinpath(f'{args.output_dir_suffix}')
    output_path.mkdir(parents=True, exist_ok=True)

    for index in range(args.first_traj_index,
                       args.first_traj_index+args.N_trajectories):
        print(f'Working on trajectory {index:04d}')

        # input nonequilibrium trajectory
        input_trajectory = input_path.joinpath(
            f'{args.input_name}_{index:04d}.gsd')
        assert input_trajectory.is_file()

        # output nonequilibrium trajectory
        output_trajectory = output_path.joinpath(
            f'nonequilibrium{args.output_name_suffix}_{index:04d}.gsd')
        if args.no_overwrites and output_trajectory.exists():
            print(f'File "{output_trajectory}" already exists')
            continue

        # instantiate nonequilibrium simulation
        simulation, logger = setup_nonequilibrium_simulation(
            parameters, device, random, str(input_trajectory), input_frame_index=-1)

        # Define a trigger that waits a burn-in period before writing output to file
        trigger = hoomd.trigger.Periodic(int(parameters["N_dumpevery"]), 1)

        # Instantiate a writer that will write trajectory and observable data
        gsd_writer = hoomd.write.GSD(
            filename=output_trajectory, mode='wb', trigger=trigger,
            filter=hoomd.filter.All(), logger=logger)
        simulation.operations.writers.append(gsd_writer)

        # Define additional writer for tabular output of scalar loggables
        _ = setup_table_writer(
            simulation, logger, output_trajectory, trigger=hoomd.trigger.After(0))

        simulation.run(int(parameters["N_timesteps"]) + 1)
        simulation.operations.writers[0].flush()
